\documentclass[10pt]{article}

\usepackage[margin=0.6in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{tcolorbox}
\tcbuselibrary{skins,breakable}

\pagestyle{empty}

% -----------------------------
% CHEAT-SHEET STYLES
% -----------------------------
\setlength{\parindent}{0pt}
\setlength{\parskip}{2pt}
\setlength{\columnsep}{0.25in}

\newtcolorbox{CSBox}[1][]{%
  enhanced,
  breakable,
  colback=white,
  colframe=black,
  boxrule=0.4pt,
  arc=2pt,
  left=4pt,right=4pt,top=4pt,bottom=4pt,
  fonttitle=\bfseries\footnotesize,
  title=#1
}

\newcommand{\key}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\begin{center}
{\Large \textbf{MMAE 350 Midterm 1 --- Sample Cheat Sheet}}\\[2pt]
{\footnotesize (Two-column layout; print double-sided if allowed)}
\end{center}

\begin{multicols}{2}

% =========================================================
\begin{CSBox}[Python \& Jupyter Essentials]
\key{Virtual environment:} isolates packages per course/project; improves reproducibility.\\
\key{Jupyter notebook:} best for mixing derivations, code, plots, and short write-ups.\\
\key{Common workflow:} activate env $\rightarrow$ start Jupyter $\rightarrow$ run cells top-to-bottom.

\key{Indexing reminder:}
\[
\code{range(n)}:\ 0,1,\dots,n-1 \qquad
\code{range(1,n+1)}:\ 1,2,\dots,n
\]

\key{Loops:}
\begin{itemize}[leftmargin=1.2em, itemsep=1pt]
\item \code{for} loop: repeat a known number of steps
\item \code{while} loop: repeat until a condition is met
\end{itemize}

\key{Conditionals:}
\begin{itemize}[leftmargin=1.2em, itemsep=1pt]
\item Two cases: \code{if / else}
\item Three cases: \code{if / elif / else}
\end{itemize}

\key{NumPy idea:} use arrays + vectorized operations for speed (vs. Python loops).
\end{CSBox}

% =========================================================
\begin{CSBox}[Tiny Pseudocode Patterns]
\key{Sum of a vector $x$:}
\begin{verbatim}
s = 0
for i = 1..n:
    s = s + x[i]
\end{verbatim}

\key{Count positives in vector $x$:}
\begin{verbatim}
count = 0
for i = 1..n:
    if x[i] > 0:
        count = count + 1
\end{verbatim}

\key{Extract diagonal of matrix $A$:}
\begin{verbatim}
for i = 1..n:
    d[i] = A[i,i]
\end{verbatim}
\end{CSBox}

% =========================================================
\begin{CSBox}[Matrix Algebra Basics]
\key{Shapes:} $A\in\mathbb{R}^{m\times n}$, $x\in\mathbb{R}^{n}$, $Ax\in\mathbb{R}^{m}$.\\
\key{Matrix--vector product:}
\[
b_i=\sum_{j=1}^{n} A_{ij}x_j
\]
\key{Transpose:} $(A^T)_{ij}=A_{ji}$.\\
\key{Invertible:} unique solution to $Ax=b$ for every $b$; $\det(A)\neq 0$.\\
\key{Avoid explicit inverse:} compute $x$ by solving $Ax=b$ (more stable, faster) rather than $x=A^{-1}b$.

\end{CSBox}

% =========================================================
\begin{CSBox}[Matrix--Vector Multiply (Nested Loops)]
\key{Pseudocode:}
\begin{verbatim}
for i = 1..n:
    b[i] = 0
    for j = 1..n:
        b[i] = b[i] + A[i,j]*x[j]
\end{verbatim}

\key{NumPy:} \code{b = A @ x}
\end{CSBox}

% =========================================================
\begin{CSBox}[Solving Linear Systems: Big Picture]
Solve \key{$Ax=b$}.\\
\key{Direct methods:} finite number of steps (Gaussian elimination; Thomas for tridiagonal).\\
\key{Iterative methods:} repeated sweeps (Gauss--Seidel).

\key{Residual:}
\[
r = b - Ax
\]
Stop when $\|r\|$ is small (or when max change in $x$ is small).
\end{CSBox}

% =========================================================
\begin{CSBox}[Gaussian Elimination (Outline)]
\key{Goal:} transform to upper-triangular $U$ then back substitute.

\key{Forward elimination idea:}\\
Use row operations to zero out entries below the pivot $A_{kk}$.

\key{Back substitution:}
\[
x_n=\frac{b_n}{U_{nn}},\qquad
x_i=\frac{b_i-\sum_{j=i+1}^n U_{ij}x_j}{U_{ii}}
\]
\end{CSBox}

% =========================================================
\begin{CSBox}[Thomas Algorithm (Tridiagonal)]
For tridiagonal $A$ with subdiag $a_i$, diag $d_i$, superdiag $c_i$.

\key{Forward sweep:} define modified coefficients $d_i',\,c_i',\,b_i'$.
\[
d_1' = d_1,\qquad
c_1' = \frac{c_1}{d_1'},\qquad
b_1' = \frac{b_1}{d_1'} .
\]
For $i=2,\dots,n$:
\[
d_i' = d_i - a_i\,c_{i-1}',\qquad
c_i' = \frac{c_i}{d_i'},\qquad
b_i' = \frac{b_i - a_i\,b_{i-1}'}{d_i'} .
\]

\key{Back substitution:}
\[
x_n = b_n',\qquad
x_i = b_i' - c_i' x_{i+1}\quad (i=n-1,\dots,1).
\]

\key{Key fact:} $O(n)$ work (very fast).
\end{CSBox}
% =========================================================
\pagebreak
\begin{CSBox}[Gauss--Seidel (Idea + One Sweep)]
\key{Idea:} use newest values immediately as you sweep through unknowns.

\key{Update form:}
\[
x_i \leftarrow \frac{1}{A_{ii}}
\left(b_i-\sum_{j\ne i}A_{ij}x_j\right)
\]

\key{One-sweep pseudocode:}
\begin{verbatim}
for i = 1..n:
    sigma = 0
    for j = 1..n, j != i:
        sigma += A[i,j]*x[j]
    x[i] = (b[i]-sigma)/A[i,i]
\end{verbatim}

\key{Convergence helpers:} diagonal dominance often helps:
\[
|A_{ii}| \ge \sum_{j\ne i}|A_{ij}|
\]
\end{CSBox}

% =========================================================
\begin{CSBox}[Nonlinear Equations: Newtonâ€™s Method (1D)]
Solve \key{$f(x)=0$}.

\key{Linearization (Taylor):}
\[
f(x)\approx f(x_k)+f'(x_k)(x-x_k)
\]

\key{Newton update:}
\[
x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)}
\]

\key{Residual:} $r_k=|f(x_k)|$.

\key{Quadratic convergence (conditions):}
The function has a well-defined derivative near the root, the derivative at the root is not zero, and the initial guess is sufficiently close to the true solution.
\end{CSBox}

% =========================================================
\begin{CSBox}[Newton Pseudocode (Scalar)]
\begin{verbatim}
given f, fprime, x0, tol, max_iter
x = x0
for k = 1..max_iter:
    fx = f(x)
    if abs(fx) < tol:
        stop
    fpx = fprime(x)
    x = x - fx/fpx
end
\end{verbatim}

\key{Common failure modes:} bad initial guess; derivative near zero; divergence.
\end{CSBox}

% =========================================================
\begin{CSBox}[Newton for Systems (Memory Form)]
Solve \key{$F(x)=0$} with $x\in\mathbb{R}^n$.

\key{Linear solve each iteration:}
\[
J(x_k)\,\Delta x = -F(x_k)
\]
\[
x_{k+1}=x_k+\Delta x
\]

\key{Pseudocode:}
\begin{verbatim}
x = x0
for k = 1..max_iter:
    r = norm(F(x))
    if r < tol: stop
    J = Jacobian(x)
    solve J*dx = -F(x)
    x = x + dx
end
\end{verbatim}
\end{CSBox}

% =========================================================
\begin{CSBox}[SymPy \texorpdfstring{$\rightarrow$} NumPy Reminder]
\key{SymPy:} define symbolic $f$, compute $f'$, simplify.\\
\key{NumPy:} evaluate numerically inside loops for speed.

Typical workflow:
\begin{itemize}[leftmargin=1.2em, itemsep=1pt]
\item Symbolic: build $f(x)$ and $f'(x)$ in SymPy
\item Convert: create numerical callables (e.g., \code{lambdify})
\item Iterate: run Newton (or GS) numerically
\end{itemize}
\end{CSBox}

\end{multicols}

\end{document}