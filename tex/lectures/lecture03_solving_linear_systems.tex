\documentclass{beamer}

% --- Shared preamble ---
\input{../preamble/beamer_styles.tex}

\title{Matrix Algebra for Engineering Systems}
\subtitle{Solving Linear Systems}
\author{MMAE 350}
\date{Tuesday, January 20}

\begin{document}

%-------------------------------------------------
\begin{frame}
\titlepage
\end{frame}

%-------------------------------------------------
\begin{frame}{Where We Are in the Course}
In the previous lecture, we:
\begin{itemize}
\item Introduced matrices and vectors
\item Defined the identity matrix and matrix inverse
\item Wrote linear systems in the form \(A\mathbf{x}=\mathbf{b}\)
\item Explored numerical issues using the Hilbert matrix
\end{itemize}

\vspace{1em}
Today we focus on how engineers \emph{actually solve} linear systems.
\end{frame}

%-------------------------------------------------
\begin{frame}{Why Linear Systems Matter in Engineering}
Linear systems appear everywhere in engineering:
\begin{itemize}
\item Structural analysis (forces and displacements)
\item Heat conduction (nodal temperatures)
\item Electrical circuits (currents and voltages)
\item Fluid flow and transport problems
\end{itemize}

\vspace{1em}
In most applications:
\[
A\mathbf{x}=\mathbf{b}
\quad\text{with}\quad
A \in \mathbb{R}^{n\times n}, \; n \gg 1.
\]
\end{frame}

%-------------------------------------------------
\begin{frame}{The Linear System \(A\mathbf{x}=\mathbf{b}\)}
We seek a vector \(\mathbf{x}\) such that:
\[
A\mathbf{x} = \mathbf{b}.
\]

\begin{itemize}
\item \(A\): system matrix (geometry, material properties, connectivity)
\item \(\mathbf{x}\): unknowns (displacements, temperatures, potentials)
\item \(\mathbf{b}\): known loads, sources, or boundary data
\end{itemize}

\vspace{1em}
This is the core mathematical structure of many engineering models.
\end{frame}

%-------------------------------------------------
\begin{frame}{Why Not Use the Matrix Inverse?}
From algebra, we know:
\[
\mathbf{x} = A^{-1}\mathbf{b}.
\]

\vspace{1em}
However, in practice:
\begin{itemize}
\item Computing \(A^{-1}\) is expensive
\item It amplifies numerical errors
\item It is unnecessary for solving systems
\end{itemize}

\alert{Engineers almost never compute matrix inverses explicitly.}
\end{frame}

%-------------------------------------------------
\begin{frame}{What We Learned from the Hilbert Matrix}
The Hilbert matrix example showed that:
\begin{itemize}
\item Some matrices are \emph{ill-conditioned}
\item Small changes in \(\mathbf{b}\) can cause large changes in \(\mathbf{x}\)
\item Numerical accuracy depends on the matrix, not just the algorithm
\end{itemize}

\vspace{1em}
This motivates solving linear systems carefully.
\end{frame}

%-------------------------------------------------
\begin{frame}{Solving Linear Systems: The Right Way}
Instead of computing \(A^{-1}\), we:
\[
\boxed{\text{Solve } A\mathbf{x}=\mathbf{b} \text{ directly}}
\]

\begin{itemize}
\item Gaussian elimination
\item LU factorization
\item Iterative methods (later in the course)
\end{itemize}

These approaches are:
\begin{itemize}
\item More efficient
\item More stable
\item Scalable to large systems
\end{itemize}
\end{frame}

%-------------------------------------------------
\begin{frame}{Gaussian Elimination (Conceptual View)}
Gaussian elimination:
\begin{itemize}
\item Transforms the system into an equivalent upper-triangular system
\item Uses row operations
\item Preserves the solution
\end{itemize}

\vspace{1em}
After elimination:
\[
U\mathbf{x}=\mathbf{c},
\]
which can be solved by back-substitution.
\end{frame}

%-------------------------------------------------
\begin{frame}{LU Factorization}
Many solvers factor the matrix:
\[
\boxed{A = LU}
\]

\begin{itemize}
\item \(L\): lower triangular
\item \(U\): upper triangular
\end{itemize}

Then solve:
\[
\begin{aligned}
L\mathbf{y} &= \mathbf{b}, \\
U\mathbf{x} &= \mathbf{y}.
\end{aligned}
\]

This is the foundation of most numerical linear algebra software.
\end{frame}

%-------------------------------------------------
\begin{frame}{What Software Actually Does}
When you write in Python:
\[
\texttt{x = np.linalg.solve(A, b)}
\]

Behind the scenes:
\begin{itemize}
\item No inverse is computed
\item The system is factorized
\item Forward and backward substitution are used
\end{itemize}

\vspace{1em}
This is exactly what professional engineering codes do.
\end{frame}

%-------------------------------------------------
\begin{frame}{Conditioning and Accuracy}
The accuracy of the solution depends on:
\begin{itemize}
\item The conditioning of \(A\)
\item The numerical precision
\item The solver algorithm
\end{itemize}

\vspace{1em}
Even a \emph{perfect} algorithm cannot fix a badly conditioned problem.
\end{frame}

%-------------------------------------------------
\begin{frame}{Key Takeaways}
\begin{itemize}
\item Linear systems are central to engineering analysis
\item The form \(A\mathbf{x}=\mathbf{b}\) appears everywhere
\item Matrix inverses are almost never used in practice
\item Conditioning matters as much as algorithms
\item Modern solvers rely on matrix factorization
\end{itemize}
\end{frame}

%-------------------------------------------------
%\begin{frame}{Looking Ahead}
%Next steps:
%\begin{itemize}
%\item Iterative solvers for large systems
%\item Residuals and convergence
%\item Connections to finite element methods
%\end{itemize}

%\vspace{1em}
%Everything builds on the structure of \(A\mathbf{x}=\mathbf{b}\).
%\end{frame}

\end{document}